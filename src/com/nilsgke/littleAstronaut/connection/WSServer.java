package com.nilsgke.littleAstronaut.connection;

import java.io.*;
import java.net.*;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import static com.nilsgke.littleAstronaut.connection.WSData.printHex;

public class WSServer {
  public enum Status {
    STOPPED, STARTING, RUNNING
  }

  private static final int PORT = 8080;
  private static final Set<Socket> clients = Collections.synchronizedSet(new HashSet<>());
  public static final Map<Byte, WSData.Player> players = Collections.synchronizedMap(new HashMap<>());
  private Status status = Status.STOPPED;
  private ServerSocket serverSocket;
  private Thread serverThread;

  private static byte idCounter = 0; // reflects current id, in use; user, hosting the server is id 0

  public static void main(String[] args) {
    var server = new WSServer();
    server.start();
  }

  public Status getStatus() {
    return status;
  }

  public void start() {
    if (status == Status.RUNNING) {
      System.out.println("Server is already running.");
      return;
    }
    status = Status.STARTING;
    serverThread = new Thread(() -> {
      try {
        serverSocket = new ServerSocket(PORT);
        status = Status.RUNNING;
        String serverIp = getServerIpAddress();
        System.out.println("WebSocket server started on " + serverIp + ":" + PORT);

        // Broadcast player positions every 13 ms (~60 fps)
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(() -> broadcastBytes(WSData.PlayerList.encodeWithIdentifierFromPlayerMap(players)), 0, 13, TimeUnit.MILLISECONDS);

        // accept users connecting
        while (status == Status.RUNNING) {
          Socket clientSocket = serverSocket.accept();
          clients.add(clientSocket);
          new Thread(new ClientHandler(clientSocket)).start();
        }

      } catch (IOException e) {
        e.printStackTrace();
      } finally {
        stop(); // Ensure resources are cleaned up
      }
    });
    serverThread.start();
  }

  public void stop() {
    if (status != Status.RUNNING) {
      System.out.println("Server is not running.");
      return;
    }

    status = Status.STOPPED;
    try {
      if (serverSocket != null && !serverSocket.isClosed()) {
        serverSocket.close();
      }
      for (Socket client : clients) {
        client.close();
      }
      clients.clear();
      serverThread.join(); // Wait for the server thread to finish
      System.out.println("WebSocket server stopped.");
    } catch (IOException | InterruptedException e) {
      e.printStackTrace();
    }
  }

  public void updateOwnPosition(byte level, double x, double y) {
    players.put((byte) 0, new WSData.Player((byte) 0, level, x, y));
  }

  public String getWebSocketURI() {
    return getServerIpAddress() + ":" + PORT; // Use server's IP address
  }

  private String getServerIpAddress() {
    try {
      InetAddress localHost = InetAddress.getLocalHost();
      return localHost.getHostAddress(); // Get the server's IP address
    } catch (UnknownHostException e) {
      e.printStackTrace();
      return "localhost"; // Fallback to localhost if unable to determine IP
    }
  }

  private void broadcastBytes(byte[] message) {
    for (Socket client : clients) sendMessageToClient(client, message);
  }

  private static void sendMessageToClient(Socket client, byte[] message) {
    try {
      OutputStream out = client.getOutputStream();
      sendMessageToClient(out, message);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private static void sendMessageToClient(OutputStream out, byte[] message) {
    try {
      out.write(0x82); // FIN + Binary opcode
      if (message.length <= 125) {
        out.write(message.length);
      } else if (message.length <= 65535) {
        out.write(126);
        out.write((message.length >> 8) & 0xFF);
        out.write(message.length & 0xFF);
      }
      out.write(message);
      out.flush();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  // base generated by GPT 4o (run, generateAcceptKey and readMessage)
  private static class ClientHandler implements Runnable {
    private final Socket clientSocket;

    public ClientHandler(Socket socket) {
      this.clientSocket = socket;
    }

    @Override
    public void run() {
      try (InputStream in = clientSocket.getInputStream(); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {

        // Get the client's IP address
        String clientIp = clientSocket.getInetAddress().getHostAddress();
        System.out.println("Client connected: " + clientIp);

        // Perform WebSocket handshake
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        String line;
        while (!(line = reader.readLine()).isEmpty()) {
          if (line.startsWith("Sec-WebSocket-Key")) {
            String key = line.split(": ")[1];
            String responseKey = generateAcceptKey(key);
            out.println("HTTP/1.1 101 Switching Protocols");
            out.println("Upgrade: websocket");
            out.println("Connection: Upgrade");
            out.println("Sec-WebSocket-Accept: " + responseKey);
            out.println();
            out.flush(); // Ensure headers are sent immediately

            // Wait a brief moment for handshake to complete
            try {
              Thread.sleep(100);
            } catch (InterruptedException e) {
              throw new RuntimeException(e);
            }

            // Assign and send ID to client
            idCounter++;
            sendMessageToClient(clientSocket.getOutputStream(), WSData.ID.encodeWithIdentifier(idCounter));
            break;
          }
        }


        // Handle messages from the client
        byte[] message;
        while ((message = readMessage(in)) != null) handleMessage(message);

      } catch (IOException | NoSuchAlgorithmException e) {
        e.printStackTrace();
      } finally {
        try {
          clientSocket.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
        clients.remove(clientSocket);
        System.out.println("CLEANING UP HERE");
        players.clear(); // clear player set so all players are removed and will be back on next client message
      }
    }

    private byte[] readMessage(InputStream in) throws IOException {
      int firstByte = in.read();
      if (firstByte == -1) return null;

      boolean fin = (firstByte & 0x80) != 0; // FIN flag
      int opcode = firstByte & 0x0F; // Opcode

      if (opcode == 8) {
        System.out.println("Client requested to close connection.");
        return null;
      }

      int secondByte = in.read();
      if (secondByte == -1) return null;

      boolean masked = (secondByte & 0x80) != 0;
      int payloadLength = secondByte & 0x7F;

      if (payloadLength == 126) {
        payloadLength = (in.read() << 8) | in.read();
      } else if (payloadLength == 127) {
        for (int i = 0; i < 6; i++) in.read(); // Skip the first 6 bytes (only last 2 are used)
        payloadLength = (in.read() << 8) | in.read();
      }

      byte[] maskingKey = new byte[4];
      if (masked) {
        in.read(maskingKey, 0, 4);
      }

      byte[] payload = new byte[payloadLength];
      int bytesRead = 0;
      while (bytesRead < payloadLength) {
        int read = in.read(payload, bytesRead, payloadLength - bytesRead);
        if (read == -1) return null;
        bytesRead += read;
      }

      if (masked) {
        for (int i = 0; i < payload.length; i++) {
          payload[i] ^= maskingKey[i % 4]; // Unmask payload
        }
      }

      return payload;  // This now contains just the actual message data, not the WebSocket frame
    }

    private void handleMessage(byte[] message) {
      System.out.println("got a new message");
      printHex(message);

      byte identifier = message[0];
      byte[] data = Arrays.copyOfRange(message, 1, message.length);

      switch (identifier) {
        case WSData.IDRequest.IDENTIFIER -> {
          System.out.println("got id request");
          idCounter++;
          try {
            var messageOut = clientSocket.getOutputStream();
            sendMessageToClient(messageOut, WSData.ID.encodeWithIdentifier(idCounter));
          } catch (IOException e) {
            throw new RuntimeException(e);
          }
          System.out.println("id request handled");
        }
        case WSData.Player.IDENTIFIER -> {
          var player = WSData.Player.decode(data);
          players.put(player.id(), player);
        }
        default -> System.err.println("unsupported message received on server!\nIdentifier: " + identifier);

      }

    }

    private String generateAcceptKey(String key) throws NoSuchAlgorithmException {
      String acceptKey = key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
      return Base64.getEncoder().encodeToString(java.security.MessageDigest.getInstance("SHA-1").digest(acceptKey.getBytes()));
    }
  }
}
